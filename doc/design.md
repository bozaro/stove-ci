# Дизайн
## Название
Рабочее название проекта: Печка

## Обзор имеющихся решений
Здесь представлен субъективный перечень решений, которые используются в существующих CI.

### Jenkins
#### Jenkinsfile
В Jenkins есть два варианта описания сборки:

 - императивный (scripted pipeline);
 - декларативный (declarative pipeline).

Изначально в Jenkins появилось императивное описание сборки.

Так как единственный способ выяснить, что будет делать императивная сборка - выполнить её, появился ряд проблем:

 - объявление параметров в pipeline для корректного поведения должно быть исполнено до начала сборки (эта проблема
   закостылена тем, что изменение параметров в сборке влияет на следующую сборку);
 - визуализация сборки работает так себе: пока шаг не выполнится его нельзя отобразить (эта проблема закостылена
   тем, что происходит слияние схемы от текущей и предыдущей сборки);

Через некоторое время в Jenkins появилось декларативное описание сборки.

Теоретически оно могло решить имеющиеся проблемы, но:

 - в декларативной сборке не достаточно выразительности (например: фиксированный список stage-ей). Из-за этого иногда
   приходится возвращаться к императивной сборке, которая разительно отличается синтаксически;
 - декларативная сборка де-факто реализована поверх императивной, так что сохраняет все имеющиеся недостатки, хотя
   субъективно отображение декларативной сборки работает более корректно.

#### Тесты выполняются в Docker
Инкапсуляция сборочного/тестового окружения в Docker-контейнер позволяет:

 - переложить бремя управления окружением на людей, которые занимаются разработкой проекта, а не поддержкой CI;
 - разные проекты могут иметь разные тестовые окружения и они не конфликтуют между собой;
 - если Dockerfile лежит в репозитории с проектом, то это позволяет легко обновлять окружение вместе с кодом.

Из недостатков реализации стоит отметить:

 - отсутствие кэширования ранее собранных Dockerfile-окружений (из-за этого на каждом новом агенте первая сборка
   занимает очень много времени);
 - нет встроенного управления каталогами, которые должны сохраняться между сборками (кэши);
 - нет простого способа запустить более одного сервиса (обходится через supervisord);

#### Snippet generator
В Jenkins достаточно приятный механизм для генерации фрагментов кода для декларативной сборки.

Это сильно упрощает использование плагинов и дополнительных шагов.

### TeamCity
#### Разметка консольных логов
В TeamCity есть возможность разметить output для вывода
(https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html).

Это позволяет разделить вывод нескольких параллельно исполняемых потоков.

Из недостатков реализации надо отметить, что экранированный многострочный текст выглядит очень трудночитаемо.

#### Интеграция с тестами
TeamCity показывает в режиме реального времени результат выполнения тестов.

Так же в TeamCity очень приятные отчеты по времени выполнения тестов.

## Примеры выполняемых сценариев
### Запуск тестов после коммита
**Общее описание:** после выполнения `push` в репозиторий срабатывает автоматичский запуск тестов.

Результат запуска тестов может провоцировать нотификацию в Slack.

**Подводные камни:**

 - При сборке новой ветки, нужно уметь понимать, какую сборку можно взять за образец.

   От этого, как минимум, зависит changelist, ожидаемое время сборки и список людей, участвующих в нотификации.

 - Выполнение тестов нужно делать в параллель на нескольких нодах.

 - Существует потребность не выполнять тесты, которые не затронуты изменениями в коде и в автоматическом детекте
   мигающих тестов.

 - Тесты могут быть иметь совершенно разную форму выполнения.

 - Индикацию об имеющихся проблемах хочется иметь как можно раньше: после первого упавшего теста.

### Деплой на стенд
**Общее описание:** пользователь запускает сборку, указывает ряд параметров (например: имя стенда, версию, список
разворачиваемых компонент).

После завершения деплоя получает нотификацию в Slack.

**Подводные камни:**

 - Имя пользователя, который получает нотификацию может не совпадать с именем пользователя в CI.

 - Некоторые параметры могут зависеть друг от друга (например список компонент зависит от версии).

 - Нужен внятный механизм валидации входных параметров.

 - Нужен внятный примитив вида "собрать, если еще не собрано".

 - Логика по сборке проекта может лежать в другом репозитории.

## Базовые принципы релизации
### Акценты
При дизайне CI надо исходить из следующих приоритетов:

 - Визуализация сборки должна максимально просто отвечать на вопрос: "Что пошло не так?"

   Причем в большинстве случаев важен именно негативный сценарий развития событий.

 - Поведение по-умолчанию должно руководствоваться принципом наименьшего удивления, то есть максимально ограничивать от сайд-эффектов.

   К примеру, checkout должен брать последнюю версию, включая откат всех сделанных модификаций.

 - Логика выполнения для CI должна быть максимально инкапсулирована в репозитории с проектом.

   Количество дополнительных шагов, необходимых для подлкючения репозитория к CI должно быть минимальным.

### Термины
**Рецепт** - декларативное описание сборки, которое исполняется холопами.

**Холоп** - сборочный процесс, непосредственно исполняемый инструкции по рецепту.

### Идея описания рецептов
Вся сборка, исполняемая холопами, описывается в декларативной форме с акцентом на визуальное отображение этапов сборки.

Проблема выразительности при это решается за счёт того, что сам рецепт является артефактом скрипта, который генерируется в момент инициализации сборки.

Если сборка требует каких-то параметров, то они берутся из описания рецепта. Это позволяет решить проблему начальных значений, которые зависят от содержимого репозитория и внешних факторов, но при этом накладывает некоторые требования к скорости работы рецептов.

Базовая идея в том, что есть шаг 0, на котором генерируется рецепт, как направленный граф шагов сборки. Каждый
шаг сборки при этом так же может содержать вложенный направленный граф шагов сборки.

При этом сгенерированные ноды графа декларативны.

Часть под при этом может имеет семантику "выполнить нечто и дорастить граф". Выполнение этих шагов генерирует граф,
который подставляется вместо этого шага.

Сама генерилка графа может быть на любом языке. В вырожденом случае описание графа может просто лежать в репозитории.

По поводу изоляции генератора могут быть разные варианты, например:

 - сервис, который получает по GRPC хэш коммита и параметры сборки;
 - скрипт на lua, который генерирует граф;
 - вызов bash-скрипта из репозитория, который генерирует граф.

Базовых сценариев генерации графа в процессе выполнения два:

 1. Догенерация после получения параметров;
 2. Генерация графа после выполнения какой-то подготовительной работы (например, checkout соседнего репозитория).

Так же это должно решить проблему с прогрессом: прогресс будет виден для всей известной части графа. При этом
каждому узлу графа нужно назначать идентификатор, который позволит найти этот узел на предыдущих этапах сборки.

В этом случае так же можно будет относительно точно показать прогресс выполнения графа и предсказать время общего
выполнения.

### Архитектура
Идеологически хосты можно разделить на три группы:

 - Нода-боярин - хранение настроек и оркестрация задач;
 - Нода-пекарь - обработка рецептов и координация работы холопов;
 - Нода-холоп - процес, который непосредственно отвечает за сборку. Ключевое отличие от пекаря в том, что зтот процесс исполняется в том же пространстве, что и сборочные процессы.

Процесс-холоп копируется внутрь сборочного окружения. Из-за этого данный процесс должен иметь минимальное количество зависимостей. Идеологически к нему наиболее близок SSH-сервер: этот агент выполняет команды от пекаря и стримит результат обратно.

Принципиальное отличие от SSH в том, что данный агент должен нивилировать различие между целевыми платформами.
